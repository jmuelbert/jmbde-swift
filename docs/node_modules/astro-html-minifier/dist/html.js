import * as fs from "node:fs/promises";
import { hrtime } from "node:process";
import minifier from "@minify-html/node";
import { Logger } from "./logger.js";
import { walkDir } from "./utils.js";
const { minify } = minifier;
export const defaultHTMLOptions = {
    doNotMinifyDoctype: true,
    ensureSpecCompliantUnquotedAttributeValues: true,
    keepClosingTags: true,
    keepHtmlAndHeadOpeningTags: true,
    keepSpacesBetweenAttributes: true,
    keepComments: false,
    minifyJs: true,
    minifyCss: true,
    removeBangs: false,
    removeProcessingInstructions: false,
};
export const convertUserOptions = (options) => {
    return {
        do_not_minify_doctype: options.doNotMinifyDoctype,
        ensure_spec_compliant_unquoted_attribute_values: options.ensureSpecCompliantUnquotedAttributeValues,
        keep_closing_tags: options.keepClosingTags,
        keep_html_and_head_opening_tags: options.keepHtmlAndHeadOpeningTags,
        keep_spaces_between_attributes: options.keepSpacesBetweenAttributes,
        keep_comments: options.keepComments,
        minify_js: options.minifyJs,
        minify_css: options.minifyCss,
        remove_bangs: options.removeBangs,
        remove_processing_instructions: options.removeProcessingInstructions,
    };
};
export const minifyHTML = async (dir, options) => {
    const cfg = convertUserOptions(options);
    try {
        const start = hrtime.bigint();
        let minifiedPages = 0;
        for await (const page of walkDir(dir)) {
            const content = await fs.readFile(page);
            const result = minify(content, cfg);
            await fs.writeFile(page, result);
            minifiedPages += 1;
        }
        const end = hrtime.bigint();
        Logger.success(`minified ${minifiedPages} HTML files in ${(end - start) / 1000000n}ms`);
    }
    catch (error) {
        const err = error;
        Logger.error(`Could not write HTML file: ${err.message}`);
    }
};
//# sourceMappingURL=html.js.map